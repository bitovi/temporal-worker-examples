{
  "How can I create a custom route?": "To create a custom route in your Hatchify application, you can follow these steps:\n\n1. **Install Koa Router**: If you are using Koa, it's recommended to use the `@koa/router` package to help create custom routes easily. You can install it using npm:\n\n```bash\nnpm install @koa/router\nnpm install @types/koa__router --save-dev\n```\n\n2. **Example Code**: Here is an example code snippet that demonstrates how to add a custom route to your Hatchify application:\n\n```typescript\nimport Koa from \"koa\"\nimport KoaRouter from \"@koa/router\"\nimport { hatchifyKoa, UnexpectedValueError } from \"@hatchifyjs/koa\"\nimport * as Schemas from \"../schemas\"\n\nconst app = new Koa()\nconst hatchedKoa = hatchifyKoa(Schemas, {\n  prefix: \"/api\",\n  database: {\n    uri: process.env.DB_URI,\n  }\n})\n\nconst router = new KoaRouter()\n\nrouter.get(\"/api/custom-route\", async function customRouteHandler(ctx): Promise<void> {\n  // Add your custom logic here\n  // You can access request data, query parameters, and more from `ctx`\n\n  // Example: Return a custom response\n  ctx.body = { message: \"Custom route response\" }\n})\n\napp.use(router.routes())\napp.use(hatchedKoa.middleware.allModels.all)\n\napp.listen(3000, () => {\n  console.log(\"Server started on http://localhost:3000\")\n})\n```\n\n3. **Custom Logic**: Inside the custom route handler function, you can add your custom logic, such as data manipulation, validation, or integration with third-party services. You have access to the request context (`ctx`) to handle incoming requests and send responses.\n\n4. **Middleware**: Ensure to add your custom route before the `hatchedKoa.middleware.allModels.all` middleware to properly handle the custom route logic.\n\nBy following these steps and customizing the example code provided, you can easily create custom routes in your Hatchify application to handle specific business logic or requirements.",
  "How can I see a list of all endpoints?": "To see a list of all endpoints generated by Hatchify in your application, you can use the `printEndpoints()` method provided by the `hatchedKoa` object. This method will print out a list of all the endpoints that have been generated based on your schemas.\n\nHere is an example of how you can use the `printEndpoints()` method in your code:\n\n```typescript\nimport { hatchifyKoa } from \"@hatchifyjs/koa\";\nimport * as Schemas from \"../schemas\";\n\nconst hatchedKoa = hatchifyKoa(Schemas, { prefix: \"/api\" });\n\n// Call the printEndpoints() method to print out the list of endpoints\nhatchedKoa.printEndpoints();\n```\n\nBy running this code in your application, you will see a list of all the endpoints that have been generated by Hatchify based on your schemas. This can help you understand the API routes available in your application and how they are structured.",
  "How can I setup custom validation for an endpoint?": "To set up custom validation for an endpoint in your Hatchify application, you can leverage the validation hooks provided by Hatchify. These hooks allow you to define custom validation logic for your resources.\n\nHere's a general outline of how you can set up custom validation for an endpoint:\n\n1. Define your schema with the necessary attributes and validation functions. For example, you can define a schema for an `Employee` resource with custom validation logic:\n\n```typescript\nexport const Employee = {\n  name: \"Employee\",\n  attributes: {\n    firstName: string(),\n    lastName: string(),\n    startDate: datetime(),\n    endDate: datetime(),\n  },\n  validation: {\n    startDateBeforeEndDate() {\n      const { startDate, endDate } = this as unknown as { startDate: Date; endDate: Date };\n      if (startDate && endDate && startDate > endDate) {\n        throw [\n          new UnexpectedValueError({\n            detail: \"Start date cannot be after end date.\",\n            pointer: \"data/attributes/startDate\",\n          }),\n        ];\n      }\n    },\n  },\n} satisfies PartialSchema;\n```\n\n2. Implement the custom validation logic within the validation function defined in your schema. In this example, the `startDateBeforeEndDate` function checks if the `startDate` is before the `endDate`.\n\n3. Use the custom validation function in your endpoint logic. You can call this validation function before creating or updating a resource to ensure data integrity.\n\nBy following these steps, you can easily set up custom validation for your endpoints in Hatchify, ensuring that your data meets the required criteria before being processed.",
  "How can I define an attribute as an optional integer?": "To define an attribute as an optional integer, you can use the `integer` function from the Hatchify open-source project in TypeScript. Here is an example of how you can define an optional integer attribute:\n\n```typescript\nimport { integer } from '@hatchifyjs/core';\n\nexport const ExampleModel = {\n  name: 'ExampleModel',\n  attributes: {\n    optionalNumber: integer({ required: false }),\n  },\n};\n```\n\nIn this example, the `optionalNumber` attribute is defined as an optional integer by setting `required: false` in the `integer` function. This means that the `optionalNumber` attribute can be `null` or an integer value.",
  "How can I define schema relationships?": "To define schema relationships in your TypeScript application using the Hatchify open-source project, you can utilize the `belongsTo`, `hasMany`, and `hasOne` functions provided by the `@hatchifyjs/core` package. Here's a brief overview of how you can define different types of relationships:\n\n### Belongs To Relationship\n- Use `belongsTo` to create a relationship from the current schema to the target schema.\n- Example:\n  ```typescript\n  import { belongsTo } from \"@hatchifyjs/core\";\n\n  const Player = {\n    name: \"Player\",\n    relationships: {\n      team: belongsTo(\"Team\"),\n    },\n  };\n  ```\n\n### Has Many Relationship\n- Use `hasMany` to create a one-to-many relationship from the current schema to the target schema.\n- Example:\n  ```typescript\n  import { hasMany } from \"@hatchifyjs/core\";\n\n  const Team = {\n    name: \"Team\",\n    relationships: {\n      players: hasMany(\"Player\"),\n    },\n  };\n  ```\n\n### Has One Relationship\n- Use `hasOne` to create a one-to-one relationship from the current schema to the target schema.\n- Example:\n  ```typescript\n  import { hasOne } from \"@hatchifyjs/core\";\n\n  const SalesPerson = {\n    name: \"SalesPerson\",\n    relationships: {\n      account: hasOne(\"Account\"),\n    },\n  };\n  ```\n\nBy defining these relationships within your schema objects, you can establish the connections between different models in your application.",
  "How can I query for data created between two dates?": "To query for data created between two dates using Hatchify, you can utilize the `$gte` (greater than or equal to) and `$lte` (less than or equal to) operators on the date attribute. Here's an example of how you can construct the query:\n\n```typescript\n// Query for data created between two dates\nconst startDate = \"2023-01-01\";\nconst endDate = \"2023-12-31\";\n\n// Construct the filter query\nconst filterQuery = `filter[createdAt][$gte]=${startDate}&filter[createdAt][$lte]=${endDate}`;\n\n// Use the filter query in your API request\nconst apiUrl = `/api/data?${filterQuery}`;\n```\n\nIn this example:\n- `startDate` represents the start date of the range.\n- `endDate` represents the end date of the range.\n- The `filterQuery` string is constructed with the `$gte` and `$lte` operators on the `createdAt` attribute.\n- Finally, you can use the `filterQuery` in your API request to retrieve data created between the specified dates.\n\nMake sure to replace `createdAt` with the actual attribute representing the creation date in your data model.",
  "How can I query data with pagination?": "To query data with pagination using the Hatchify open-source project in TypeScript, you can follow the pagination techniques provided in the documentation. Here are the steps for different pagination methods:\n\n### Offset and Limit Pagination\n\n1. Use the `page[offset]` parameter to determine the starting point in the dataset.\n2. Use the `page[limit]` parameter to specify the maximum number of records to include on each page.\n\nExample URL for fetching 10 todos, skipping the first 5:\n```curl\nGET /api/todos?page[offset]=5&page[limit]=10\n```\n\n### Page-Based Pagination\n\n1. Use the `page[number]` parameter to specify the desired page number.\n2. Use the `page[size]` parameter to determine the number of records per page.\n\nExample URL for fetching the second page of todos where each page has 20 results:\n```curl\nGET /api/todos?page[number]=2&page[size]=20\n```\n\nBy following these techniques and adjusting the parameters according to your requirements, you can effectively query data with pagination using Hatchify in TypeScript."
}
